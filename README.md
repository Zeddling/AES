# Advanced Encryption Standard(AES)

Code quality: <strong>Spaghetti with a chance of meatballs</strong>

AES is a variant of the Rjindael block cipher.
It's a symmetric key algorithm.
It uses the [substitution-permutation network](https://en.wikipedia.org/wiki/Substitution%E2%80%93permutation_network) design principle which is a series of linked mathematical operations.

<p align="center">
    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/AES_%28Rijndael%29_Round_Function.png/250px-AES_%28Rijndael%29_Round_Function.png">
</p>

AES has a fixed block size of 128 bits and a key size of 128, 192 or 256 bits.
For more information: [here](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)

## Crates used

[hex](https://crates.io/crates/hex) - Encoding and decoding data into/from hexadecimal representation.

# Method of Implementation

### Key Expansion

AES 128 operates under a 11 round transformation. As a result, 10 additional unique keys are required to complete the entire rounds. The creation of these additional keys involve the following steps:

1. rot_word - The third word of the key n is cyclically rotated to the left by one shift.
2. sub_byte - The values of result from the rot_word function are then substituted using an SBOX table.
3. add_rcon - The sub_byte vector and a round constant vector are XOR'ed. The result is then XOR'ed with the first column of the key n. The subsequent columns are generated by key n[i] XOR key n+1[i-1].

### Encryption

#### Input

The input(plaintext and cipher key) is first decoded into hexadecimal then divided into a 4x4 matrix. We first perform key expansion to get all the required keys. Encryption involves various transformations:

##### sub_byte

Involves substituting the block values with their correspoing values in the SBOX table.

##### shift_rows

This performs a left rotation on the rows of the provided matrix. The degree of the rotation is the row's index.

##### mix_columns

It involves the result of multiplying the mix's column fixed matrix and the provided state. Overflows in the multiplication process is handled by performing an XOR with 1b on the result and trimming the first 1 off the hexadecimal digit.

##### round_key_xor

We finally perform an XOR on the current process' key and the mix_column's result.

The first round only involves the round_key_xor whereas the last round does not involve the mix_columns transformation.

### Decryption

In the decryption algorithm, we have a separate SBOX matrix which is the inverse of the encryption SBOX. In the shift rows step, we perform a right circular shift of the word bytes by degree of the row's index. In mix columns stage, we use a matrix which is the inverse of the encryption mix column matrix. The round keys are also transformed using the inverse mix column except for the first and last round making the decryption algorithm to closely resembles the encryption algorithm.

More information about the process can be found [here](https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf).
